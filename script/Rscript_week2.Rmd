---
title: "script_scarabi"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## R Markdown

```{r Load Data}
library(Seurat)
library(tximport)

samps <- c("SRR8257100",
"SRR8257101",
"SRR8257102",
"SRR8257103",
"SRR8257104",
"SRR8257105",
"SRR8257106")

```

# path to the output directory of Alevin quant run 

```{r matrice de compte}

files <- file.path(
  paste("~/mydatalocal/tpngsscarabi_lena/data/quant/",samps,"/alevin/quants_mat.gz", sep=""))
file.exists(files)
```

```{r}
txis <- lapply(files, function(f) tximport(files = f, type="alevin"))
```
# Il faut créer 4 objets Seurat indépendants pour les 4 échantillons de WT 
On ne peut pas les compiler plus tôt car ils proviennent d'expériences indépendantes et donc peuvent contenir les mêmes identifiants. 
Il faut donc les séparer et on les mergera ensuite. 

avec min.cells = 3 on retire les gènes exprimés dans moins de 3 cellules 

avec min.features = 200 on retire les cellules exprimant moins de 200 gènes 

avec add.cell.ids = samps[1:4] on rend chaque cellule identifiée de manière unique 

```{r création des objets Seurat}
 s1 <- CreateSeuratObject(counts = txis[[1]]$counts , min.cells = 3, min.features = 200, project = samps[1])
 s2 <- CreateSeuratObject(counts = txis[[2]]$counts , min.cells = 3, min.features = 200, project = samps[2])
 s3 <- CreateSeuratObject(counts = txis[[3]]$counts , min.cells = 3, min.features = 200, project = samps[3])
 s4 <- CreateSeuratObject(counts = txis[[4]]$counts , min.cells = 3, min.features = 200, project = samps[4])
scarabiWT <- merge(s1, y = c(s2, s3,s4), add.cell.ids = samps[1:4], project = "scarabiWT")
```

```{r}
scarabiWT[["percent.mt"]] <- PercentageFeatureSet(scarabiWT, pattern = "ATM")
scarabiWT[["percent.chloro"]] <- PercentageFeatureSet(scarabiWT, pattern = "ATC")

 VlnPlot(scarabiWT, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.chloro"), ncol = 4)
```
On remarque ici que les échantillons 100 et 101 ont anormalement beaucoup de gènes mitochondriaux et chloroplastiques : il faut qu'on sélectionne les cellules qui n'ont pas trop souffert. 
Il serait intéressant de retirer les 5% de cellules les plus "mauvaises", avec le plus le gènes mitochondriaux exprimés; et mettre une valeur à 0.2 pour les chloroplastiques. 

```{r threshold}
thr_mt <- quantile(scarabiWT[["percent.mt"]]$percent.m, 0.95)
thr_chloro <- scarabiWT[["percent.chloro"]]<0.2

scarabiWT_filter <- subset(scarabiWT, subset = percent.chloro < 0.2 & percent.mt < thr_mt )
```

```{r graphs avec thr}
VlnPlot(scarabiWT_filter, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.chloro"), ncol = 4)
```
Avec l'affiche de scarabiWT_filter, on voit que nous travaillons maintenant avec 11321 cellules, et 23443 gènes. 
( Avant le filtre, on travaillait avec 11920 et 23443 gènes )

Pour avoir plus de détails sur le nombre de cellules contenues par échantillon : table(scarabiWT$orig.ident) 

#Il faut maintenant normaliser les données 
L'objectif est que la médiane d'expression entre les quatre echantillons soit la même, tout en gardant les rapports d'expression au sein de chaque échantillon; pour comparer ce qui est comparable. 

```{r data normalization}
scarabiWT_filter <- NormalizeData(scarabiWT_filter, normalization.method = "LogNormalize", scale.factor = 10000)
```

Ne pas s'intéresser aux gènes dont l'expression ne varie pas, ni aux gènes de "bruit". Le choix du nfeatures est légèrement difficile, on se met souvent à 10% du nombre de gènes totaux. Ici on va d'abord essayer avec 10 000 gènes, et on ajustera si nécessaire.  

```{r Identification of highly variable features}
scarabiWT_filter <- FindVariableFeatures(scarabiWT_filter, selection.method = "vst", nfeatures = 10000)

# plot variable features with and without labels
top10 <- head(VariableFeatures(scarabiWT_filter), 10)
plot1 <- VariableFeaturePlot(scarabiWT_filter)
plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)
CombinePlots(plots = list(plot1, plot2),nrow=2)
```
On fait maintenant une transformation linéaire : 

```{r Scaling}
all.genes <- rownames(scarabiWT_filter)
scarabiWT_filter <- ScaleData(scarabiWT_filter, features = all.genes)
```

On fait maintenant la PCA: (l'UMAP se basera sur la PCA)

```{r}
scarabiWT_filter <- RunPCA(scarabiWT_filter, features = VariableFeatures(object = scarabiWT_filter))

print(scarabiWT_filter[["pca"]], dims = 1:5, nfeatures = 5)
```

```{r}
VizDimLoadings(scarabiWT_filter, dims = 1:2, reduction = "pca")
```

```{r}
DimPlot(scarabiWT_filter, reduction = "pca")
```
La PCA donne des axes qui expliquent au mieux la variance du jeu de données. Les axes sont des combinaisons linéaires des gènes de départ, avec des poids différents. 

On peut maintenant faire des Heat Maps  d'expression des gènes : 

```{r}
DimHeatmap(scarabiWT_filter, dims = 1, cells = 500, balanced = TRUE)

#on représente les 500 cellules avec le plus de variations d'expression 
```
```{r}
DimHeatmap(scarabiWT_filter, dims = 1:15, cells = 500, balanced = TRUE)
```
Là on visualise selon les 15 premiers axes : on remarque que très vite les axes ne représentent plus tant que ça la variance de l'expression. Cela peut notamment être expliqué par le fait que certains gènes co-varient (sont co-régulés), donc peuvent expliquer la variation selon un même axe. 
## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

